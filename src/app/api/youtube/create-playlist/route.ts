import { google } from "googleapis";

import { adminDb } from "@/lib/firebase/admin";
import { verifyUser } from "@/lib/firebase/verify";

type SongInput = { title: string; artist: string };

const CACHE_COLLECTION = "youtube_cache";
const CACHE_TTL_DAYS = 30;

function normalizeQuery(title: string, artist: string) {
  return `${title} ${artist}`.toLowerCase().replace(/\s+/g, " ").trim();
}

async function getCachedVideoId(query: string) {
  const docRef = adminDb.collection(CACHE_COLLECTION).doc(query);
  const snap = await docRef.get();
  if (!snap.exists) return null;
  const data = snap.data() as { videoId?: string; updatedAt?: Date };
  if (!data?.videoId || !data?.updatedAt) return null;
  const ageMs = Date.now() - new Date(data.updatedAt).getTime();
  const maxAge = CACHE_TTL_DAYS * 24 * 60 * 60 * 1000;
  if (ageMs > maxAge) return null;
  return data.videoId;
}

async function setCachedVideoId(query: string, videoId: string) {
  await adminDb.collection(CACHE_COLLECTION).doc(query).set(
    {
      videoId,
      updatedAt: new Date(),
    },
    { merge: true }
  );
}

async function sleep(ms: number) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}

export async function POST(request: Request) {
  try {
    const uid = await verifyUser(request.headers.get("authorization"));
    const { playlistName, songs } = await request.json();

    if (!playlistName || !Array.isArray(songs)) {
      return Response.json({ error: "Missing payload" }, { status: 400 });
    }

    const clientId = process.env.YOUTUBE_CLIENT_ID;
    const clientSecret = process.env.YOUTUBE_CLIENT_SECRET;
    const redirectUri = process.env.NEXT_PUBLIC_YOUTUBE_REDIRECT_URI;

    if (!clientId || !clientSecret || !redirectUri) {
      return Response.json(
        { error: "Missing YouTube credentials" },
        { status: 500 }
      );
    }

    const userRef = adminDb.collection("users").doc(uid);
    const userSnap = await userRef.get();
    const youtube = userSnap.data()?.integrations?.youtube;

    if (!youtube?.refreshToken) {
      return Response.json({ 
        error: "youtube not connected. please reconnect from settings." 
      }, { status: 400 });
    }

    const oauth2 = new google.auth.OAuth2(clientId, clientSecret, redirectUri);
    oauth2.setCredentials({
      refresh_token: youtube.refreshToken,
      access_token: youtube.accessToken,
      expiry_date: youtube.expiryDate,
    });

    // ‚úÖ FIX: Auto-refresh tokens and save them back to Firestore
    oauth2.on('tokens', async (tokens) => {
      console.log('üîÑ YouTube tokens refreshed');
      await userRef.set(
        {
          integrations: {
            youtube: {
              accessToken: tokens.access_token,
              refreshToken: tokens.refresh_token ?? youtube.refreshToken,
              expiryDate: tokens.expiry_date,
            },
          },
          updatedAt: new Date(),
        },
        { merge: true }
      );
    });

    const api = google.youtube({ version: "v3", auth: oauth2 });

    console.log('üìù Creating YouTube playlist:', playlistName);

    const created = await api.playlists.insert({
      part: ["snippet", "status"],
      requestBody: {
        snippet: {
          title: playlistName,
          description: "Generated by Bud",
        },
        status: { privacyStatus: "private" },
      },
    });

    const playlistId = created.data.id;
    if (!playlistId) {
      console.error('‚ùå No playlist ID returned');
      return Response.json(
        { error: "playlist creation failed. try again." },
        { status: 500 }
      );
    }

    console.log('‚úÖ Playlist created:', playlistId);

    const inRequestCache = new Map<string, string>();
    let addedCount = 0;
    let skippedCount = 0;

    for (const song of songs as SongInput[]) {
      const q = normalizeQuery(song.title, song.artist);
      let videoId =
        inRequestCache.get(q) ?? (await getCachedVideoId(q));

      if (!videoId) {
        console.log('üîç Searching:', q);
        const search = await api.search.list({
          part: ["id"],
          q,
          maxResults: 1,
          type: ["video"],
        });
        videoId = search.data.items?.[0]?.id?.videoId ?? "";
        if (videoId) {
          inRequestCache.set(q, videoId);
          await setCachedVideoId(q, videoId);
        } else {
          console.log('‚ùå Not found:', q);
          skippedCount++;
        }
      }

      if (!videoId) continue;

      try {
        await api.playlistItems.insert({
          part: ["snippet"],
          requestBody: {
            snippet: {
              playlistId,
              resourceId: {
                kind: "youtube#video",
                videoId,
              },
            },
          },
        });
        addedCount++;
      } catch (err) {
        console.error('‚ùå Failed to add:', song.title, err);
        skippedCount++;
      }

      await sleep(150);
    }

    console.log(`‚úÖ Complete: ${addedCount} added, ${skippedCount} skipped`);

    return Response.json({
      playlistId,
      url: `https://music.youtube.com/playlist?list=${playlistId}`,
      songsAdded: addedCount,
      songsSkipped: skippedCount,
      totalSongs: songs.length,
    });
  } catch (error) {
    const apiError = error as {
      message?: string;
      code?: number;
      response?: { data?: { error?: { message?: string; code?: number } } };
    };
    
    console.error('‚ùå YouTube API Error:', {
      message: apiError.message,
      code: apiError.code || apiError.response?.data?.error?.code,
    });

    // Better error messages
    let errorMsg = "playlist creation failed.";
    const errorCode = apiError.code || apiError.response?.data?.error?.code;
    
    if (errorCode === 401 || errorCode === 403) {
      errorMsg = "youtube connection expired. reconnect and try again.";
    } else if (errorCode === 429) {
      errorMsg = "quota limit reached. try again tomorrow.";
    } else if (apiError.message?.includes('quota')) {
      errorMsg = "youtube quota exceeded. try again later.";
    }

    const details =
      process.env.NODE_ENV === "development"
        ? apiError.response?.data?.error?.message ??
          apiError.message ??
          String(error)
        : undefined;
        
    return Response.json(
      { 
        error: errorMsg,
        details,
        code: errorCode
      },
      { status: 500 }
    );
  }
}